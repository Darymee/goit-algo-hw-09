# Касова система: Видача решти

У цьому завданні реалізовано дві функції для видачі решти:

- `find_coins_greedy(amount)` — жадібний алгоритм
- `find_min_coins(amount)` — алгоритм динамічного програмування

## Алгоритми

### Жадібний алгоритм (`find_coins_greedy`)
Цей метод завжди обирає найбільший можливий номінал, який не перевищує залишкову суму.

### Часова складність:
* O(n) — де n — кількість номіналів
* Не залежить від суми, дуже швидкий
* Не гарантує мінімальну кількість монет для нестандартних наборів монет

### Алгоритм динамічного програмування (`find_min_coins`)
Цей метод знаходить мінімальну кількість монет, необхідних для точної суми, використовуючи попередні обчислення для всіх менших сум.

### Часова складність:
* O(amount × n) — де amount — сума, n — кількість номіналів
* Вимагає більше пам’яті, повільніше при великих сумах
* Але гарантує мінімальну кількість монет

| Критерій   | Жадібний алгоритм               | Динамічне програмування       |
| ---------- | ------------------------------- | ----------------------------- |
| Точність   | Не завжди оптимальна            | Завжди оптимальна             |
| Швидкодія  | Висока                          | Нижча                         |
| Складність | O(n)                            | O(amount × n)                 |
| Пам’ять    | Низьке споживання               | Високе споживання             |
| Переваги   | Простий і швидкий               | Мінімальна кількість монет    |
| Недоліки   | Може не дати найкращого рішення | Повільніший при великих сумах |



## Висновки
* Якщо монети стандартні (як [50, 25, 10, 5, 2, 1]), жадібний алгоритм працює ефективно та точно.
* Якщо набір монет нестандартний, або потрібно мінімізувати кількість монет, краще використовувати алгоритм динамічного програмування.
* Жадібний алгоритм працює швидко (O(n)) і показує хорошу продуктивність для великих сум, однак може не знайти найменшу кількість монет у загальному випадку (особливо якщо набір номіналів не канонічний).
* Алгоритм динамічного програмування завжди гарантує мінімальну кількість монет, проте потребує більше ресурсів (O(n × amount)) і працює повільніше на великих сумах.